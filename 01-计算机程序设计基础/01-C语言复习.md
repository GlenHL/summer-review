# 计算机程序设计基础(1) C语言复习

#### 1. 流程图的结构有哪些？主要类别及各自的优缺点？流程图有哪些表示方法？

+ 流程图包含：顺序、选择和循环结构
	- **当型**循环结构：某个条件成立时，重复执行循环体
	- **直到型**循环结构：重复执行循环体，到条件成立时退出
+ 流程图分类及优缺点
	- 传统流程图：不易表示层次结构、模块调用关系等
	- 结构化流程图(NS图)：不破坏结构化原则、功能域明确、层次及嵌套明确
+ 流程的表示
	- 传统流程图
	- NS图
	- 自然语言
	- 算法描述语言
	- 编程语言

#### 2. 进制之间的转换。计算机表示数字的码有哪些？
+ 进制转换
	- 十进制小数转为二进制(其他任意进制)：每次乘2取整，取整结果从上到下保留(整数部分的转换是取余，而且从下到上保留)
	- 十进制小数转为其他进制时，不一定能够完全准确地转化，需要根据精度要求进行保留
+ 原码、反码、补码、偏移码
	- 正数：反码、补码均与原码相同，补码符号位取反即为偏移码。
	- 负数：
		* 反码：原码除符号位外各位取反
			+ 0可以由00000000，11111111两种情况表示
		* 补码：反码的最后一位加1
		* 偏移码：补码的符号位取反
	- 补码和偏移码：使得正负数的加减法同普通数一样，不需要考虑符号位


#### 3. C语言中有哪些基本的数据类型？
+ 算数类型
	- 整型：基本整型、长整型、短整型、无符号整型；不同进制表示(int 占4字节)
	- 实型：十进制形式、指数形式、单精度和双精度
	- 字符型：转义字符(char 占1字节)
+ 枚举类型
+ void 类型

#### 4. C语言格式输入与输出的相关要求有哪些？

+ 格式输出：自动突破场宽限制
	- 整型(十进制)
		* %d 整型
		* %ld 长整型
		* %u 无符号整型
	- 整型(八进制)
		* %o 八进制整型
	- 整型(十六进制)
		* %x 十六进制整型
	- 实型：
		* 十进制：%f
		* 指数形：%e
		* 单精度：%f
		* 双精度：%lf
	- 字符型：%c
	- **注意**：调用printf函数时，参数是从右到左传递的
+ 格式输入
	- 格式说明符与输出部分的完全一致
	- 定义为双精度的变量必须输入时说明符为:%lf,否则出错
	- **字符输出函数**：putchar(c)，c可以是字符型、整型变量或常量或表达式
	- **字符输入函数**：getchar()，接收从键盘输入的一个字符


#### 5. C语言中的逻辑表达式有什么要求？

+ C语言中，在连续有几个&&的表达式中，从左至右只要有一个运算为假，整个结果均为假，**不再执行后面的运算**。
+ 同样，对于||的表达式，从左至右有一个结果为真，则结束判断
+ **字符串连接**：如下a##x，x为a的角标。
```c
#include <stdio.h>
#define MP(x) printf("%d", a##x)
main( )
{ 
	int a1=2, a5=4;
	MP(1);
	MP(5);
}
```

#### 6. 宏定义与编译预处理？

+ 宏定义
	- #define：宏定义
		* #define，一行写不完时，行尾加上续行符“\”
	- #undef 使已经定义的标识符变为未定义
+ 文件包含定义
	- #include <>
	- #include ""
	区别是若 #include "" 查找成功，则遮蔽 #include <> 所能找到的同名文件；否则再按照 #include <> 的方式查找文件。另外标准库头文件都放在 #include <> 所查找的位置。
+ 条件编译命令
	- 第一种形式：
	如果标识符已经定义，则程序段1编译，程序段2不编译；
	如果标识符没有定义，则程序段2编译，程序段1不编译。
	标识符的定义往往用#define命令定义
	```c
	#ifdef 	//标识符
	//程序段1
	#else	//(这部分可以省略)
	//程序段2
	#endif
	```
	- 第二种形式：
	如果标识符没有定义，则程序段1编译，程序段2不编译；
	如果标识符已经定义，则程序段2编译，程序段1不编译。
	```c
	#ifndef	//标识符
	//程序段1
	#else	//(这部分可以省略)
	//程序段2
	#endif
	```
	- 推广形式：最靠前的常量表达式值为真的部分被编译(从n+1个程序段中选择一段参加编译)

	```c
	#if 常量表达式1
	程序段1
	#elif 常量表达式2
	程序段2
	……
	#elif 常量表达式n
	程序段n
	#else
	程序段n+1
	#endif
	```
+ #pragma命令
	- 作用是只是编译器如何进行编译
	- #pragma once是将指定文件在编译器中只包含一次，防止重复定义
	```c
	#if _MSC_VER > 1000
	#pragma once
	#endif
	#include <stdio.h> //stdio.h头文件只会被编译一次
	#include <stdio.h>
	#include <stdio.h>
	……
	```
+ #line命令
	- #line **数字x** "文件名"：显示文件中第**x**行开始的计数

#### 7. C语言中循环结构可以有哪些实现方式？

+ while(条件表达式)···循环体
+ do···while(条件表达式)
+ for语句循环体
	- break：退出循环体
	- continue：结束本次循环，但不退出循环结构

#### 8. C语言中的函数、局部变量、全局变量？C语言数据的存储类型？

+ C语言允许定义空函数，但不允许嵌套定义函数
+ C语言中函数只能通过函数名返回一个值；如果有多个值，可以使用结构体等形式的变量作为返回值
+ 函数的参数传递：形参与实参结合
	- 当调用一个函数时，不是将调用模块中的实参值直接传送给被调用函数的形参，而是将**存放实参的地址**传给形参。
	- C语言函数参数的传递是通过**栈**来实现，并且是**单向传递**
	- 函数压栈顺序为：参数从右向左传递
	- 函数可以通过参数将变量值传递给被调用函数，但被调用函数不能通过参数将变量值传回调用的函数。
+ 变量的作用范围
	- 局部变量：函数内部定义的变量，只在函数范围内有效
	- 全局变量：在函数外定义的变量，从定义位置到文件结束都有效
	- 局部变量与全局变量同名时，全局变量被局部变量掩蔽
+ 变量的存储类型
	- auto：自动类型
	- static：静态类型：函数调用结束后值不会消失而保留原值
	- register：寄存器类型
	- extern：外部类型，全局变量
+ 函数的类型
	- 内部函数：只能把本文件函数调用
	- 外部函数：能被其他文件函数调用
+ 递归调用：递归函数(自己调用自己)
	- 直接递归
	- 间接递归(通过调用其他函数来调用自身)
	- 递归调用可以代替循环语句

#### 9. C语言字符串的操作？

+ **字符**数组与字符串的输入与输出
	- %c 用于输入输出单个字符
	- %s 用于输入输出一个字符串
	- 在使用格式说明符号%s为字符型数组输入数据时，字符串的分隔符是空格符，因而输入的字符串包含空格符时，只截取空格前的部分作为字符串赋给字符数组。
	- 字符型中包含一个字符串结束符，不计入字符串的长度，但需要另外占用1字节空间。
+ 常用字符串处理函数
	- puts(s) 输出字符串s
	- gets(s) 从终端读入一行字符到字符数组
	- strcat(s1,s2) 将字符串s2接到字符串s1的后面，返回字符串s1的地址
	- strcpy(s1,s2) 将字符串s2拷贝到s1中
	- strcpy(s1,s2,n) 将字符串s2的前n个字符拷贝到s1中
	- strcmp(s1,s2) 按字典序比较两个字符串大小。若返回值大于0，则s1的字典排序更靠后
	- strlen(s) 求字符串s的长度，不包含结束符```\0```
	- strlwr(s) 将字符串s中的大写字母转换成小写字母
	- strupr(s) 将字符串s中的小写字母转换成大写字母
	- sprintf(s,"输出格式",变量列表)
	- sscanf(s,"输出格式",变量列表) 

#### 10. 使用C语言实现**排序算法**举例。

+ 有序表的二分查找：
	* 只适用于顺序存储的有序表
	* 有序表：元素非递减排列
+ 冒泡排序：
	* 逐次比较相邻元素大小
	* 若前面元素大于后面的则互换位置，消除了一个**逆序**
+ 选择排序：
	* 扫描线性表，选出最小元素，交换至最前面
	* 再对剩下的子表扫描选最小
+ 插入排序：从后面开始，想象整理扑克牌

#### 11. C语言中的指针知识梳理。

+ C语言中，对内存数据存取的方法：
	- 直接存取：直接用变量名存取变量所占内存单元中的内容
	- 间接存取：从存放变量地址的指针变量中取得该变量的存储地址，再从该地址存取该变量值
+ 指针的基本概念：
	- 用途：专门用以存放其他变量所占存储空间的**首地址**
	- 指针变量的值是**地址**，普通变量的值是**数据**
+ 指针的相关操作：
	- 可以对指针变量进行初始化
	- 可以作为函数的参数，实现调用函数与被调用函数之间数据的双向传递
+ 指向指针的指针：
	- 指针：一级间接访问
	- 指向指针的指针：二级简介访问
		* 当p指向数组a的首地址时，p+i指向数组的元素a[i]
+ 指针数组：每个元素均为指针类型的数组
+ C语言动态内存分配
	- 内存申请malloc
	```c
	#include <stdlib.h>
	#include <malloc.h>
	……
	char *p;float *q;
	p = (char *)malloc(sizeof(char) * 10);
	q = (float *)malloc(sizeof(float) * 10);
	```
	- 内存释放
	```c
	free(p);
	```

#### 12. 结构体与联合体？结构体数组？结构体指针？

+ 结构体类型数据：
	- 结构体类型是用户根据数据处理的需要临时定义的一种类型
	- 初始化时，将所有的成员数据用花括号括起来
+ 结构体类型也可以形成数组、指针、指针数组等
+ 结构体变量的大小
	- 字节对齐问题：默认以结构体最长的成员对齐，不够的自动补齐
	- 可以更改对齐
	```c
	#include <stdio.h>
	#pragma pack(4)
	……
	```

#### 13. C语言中的文件操作
+ 文件：存储在外存储器上数据的集合
	- 文本文件：每个字节存放一个字符的ASCII值
	- 二进制文件：每个字节不代表一个字符
+ 文件类型指针：
	- C语言的缓冲文件系统中，用文件类型指针标识打开的文件
	- 一般操作：
		* 打开文件
		* 文件操作：读与写
		* 关闭文件
+ 文件的读写函数：
	- 字符：fgetc()、fputc()
	- 字符串：fgets()、fputs()
	- 数据块：fread()、fwrite()
	- 格式读写：fscanf()、fprintf()
	- 判断文件结束：feof()
- 文件的定位函数：
	- rewind()：将读写指针移动至文件开头
	- fseek()：将文件读写指针移动到指定位置
	- ftell()：返回文件当前的读写位置
	- fflush()：清空文件的输入输出缓冲区流
	- clearerr()：清除由于读写等操作失败引起的文件输入输出缓冲区的错误状态
	```c
	clearerr(fp);//先清除错误状态
	fflush(fp);//刷新

#### 14.C语言中的位运算
+ 六种基本的位运算：
	- 按位与
	- 按位或
	- 按位异或
	- 按位取反
	- 左移：左移k位，相当于该整数乘2^k
	- 右移：右移k位，相当于该整数除以2^k
